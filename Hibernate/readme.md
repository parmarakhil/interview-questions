#Hibernate

1. Hibernate framework
    1. It is an open source, light weight, ORM tool
    2. Hibernate implements the JPA specifications for data persistence
2. ORM Tool
    1. ORM simplifies the data creation, manipulation and access
    2. It maps objects to data stored in database
    3. Internally uses JDBC api to interact. With database
3. JPA
    1. It is a java specification that provides certain functionality and standard to ORM tools
4. Advantages
    1. Open source and light weight
    2. Fast performance
        1. Uses cache internally.
        2. There are two types of cache
            1. First level cache
            2. Second level cache (optional)
    3. Database independent query
        1. HQL (Hibernate query language) is the object oriented version of SQL. 
        2. It generates database independent queries
        3. If database changes, the queries won’t have to be written again
    4. Automatic table creation
    5. Simplifies complex joins
    6. Provides query statistics and database status
5. Hibernate Architecture
    1. There are 4 layers
        1. Java application layer
        2. Hibernate framework layer
        3. Backend api layer
        4. Database layer
6. Elements of Hibernate
    1. SessionFactory
        1. It is a factory of session and client of connectionProvider
        2. It holds second level cache of data
        3. Used to get session object
    2. Session
        1. Provides an interface between the application and data stored in database
        2. It is a short lived object and wraps the JDBC connection
        3. It is factory of transaction, query and criteria
        4. It holds first level of cache
    3. Transaction
        1. The transaction object specifies the atomic unit of work
        2. It is optional
    4. ConnectionProvider
        1. It is a factory of JDBC connection.
        2. It abstracts the application from drivermanager or datasource
        3. It is optional
    5. Transaction factory
        1. It is factory of transaction
7. Steps 
    1. Create the persistent class
        1. A no-arg constructor
            1. So that hibernate can create the instance of persistent class by newInstance() method
        2. Provide an identifier property
            1. The attribute behaves like primary key in database
        3. Declare getter and setter methods
        4. Prefer non-final class
            1. Hibernate uses the concept of proxies, that depends on the persistent class
    2. Create mapping file for persistent class
        1. If you have created persistent class using annotations, no need to create xml for below steps
        2. Hibernate-mapping
            1. It is the root element in mapping file
        3. Class
            1. It is the sub element of hibernate-mapping element, specifies persistent class
        4. Id
            1. it is sub element of class element, It specifies primary key attribute in the class
        5. Generator
            1. It is sub element of id
            2. Used to generate primary key
        6. Property
            1. It is sub element of class that specifies the property name of persistent class
    3. Create configuration file
        1. Contains information about the database and mapping file
    4. Create the class that retrieves or stores the object
    5. Run the application
8. Generator classes in hibernate
    1. Assigned
        1. It is default strategy
    2. Increment
        1. It generates the unique id only if no other process is inserting data into this table
        2. It generates short, int or long type identifier
    3. Sequence
        1. It uses the sequence of the database, if no sequence is defined it creates a sequence automatically
    4. Hilo
        1. It uses high and low algorithm to generate the id of type short, int and long
    5. Native
        1. It uses identity, sequence or hilo depending on database vendor
    6. Identity
        1. It is responsibility of database to generate unique identifier
    7. Seqhilo
        1. It uses high and low algorithm on the specified sequence name
        2. Returned id is of type short, int to long
    8. UUID
        1. It uses 128 bit UUID algorithm to generate the id
        2. The returned id is of type String, and unique within the network
    9. GUID
        1. It uses GUID generated by database of type string
    10. SELECT
        1. It uses primary key returned by database trigger
    11. Sequence-identity
        1. It is supported in oracle 10g drivers only
9. SQL dialects in hibernate
    1. The dialect specifies the type of database used in hibernate so that hibernate generate appropriate type of SQL statements
10. Inheritance mapping
    1. There are there strategies
        1. Table per hierarchy
            1. Single table is required to map the whole hierarchy
            2. An extra column (known as discriminator column) is added to identify the class
            3. Nullable values are stored in the table
        2. Table per concrete class
            1. Tables are created per class
            2. Duplicate column is added in subclass table
            3. Union-subclass subelement of class, specifies the subclass. 
            4. @inheritence(strategy=Inheritencetype.TABLE_PER_CLASS) specifies that we are using table per concrete class strategy
            5. @AttributeOverrides defines the parent class attributes will be override in this class
        3. Table per subclass
            1. Tables are created per class but related by foreign key
            2. There are no duplicate column
            3. Joined-subclass element of class issued to map the child class with parent using primary & foreign key relation
            4. @Inheritence(strategy=InheritenceType.JOINED)
            5. @PrimaryKeyJoinColumn in subclass
11. Collection mapping
    1. Supported types are
        1. Set
        2. List
        3. SortedSet
        4. Map
        5. SortedMap
        6. Collection
    2. Collection elements can be categorised in two forms
        1. Indexed - Map, List
        2. Non-indexed - Set, bag
12. Relation mapping
    1. One to many
        1. @OneToMany , @JoinColumn, @OrderColumn in parent class
    2. Many to Many
        1. @ManyToMany(targetEntity= Target.class, cascade= CascadeType.ALL)), @JoinTable(name =“intermediate table name”, joinColumns = {@JoinColumn(name=“parent_fk”)}, inverseJoinColumns = {@JoinColumn(name=“taget_fk”)}
    3. One to One
        1. @OneToOne(targetEntity=Target.class, cascade=CascadeType.ALL) in parent
        2. @OneToOne(targetEntity=Parent.class, cascade=CascadeType.ALL) in target
    4. Many to One
        1. @ManyToOne(cascade=CascadeType.ALL) in parent
13. Transaction Management
    1. A transaction represents unit of work
    2. It can be described by ACID property (Atomicity, Consistency, Isolation, Durability)
    3. A transaction is associated with a session and instantiated by calling session.beginTransaction()
        1. Methods are
            1. Void begin() —> starts a new transaction
            2. Void commit() —> ends the unit of work unless we are in FlushMode.NEVER
            3. Void rollback() —> forces this transaction to rollback
            4. Void setTimout(int seconds) —> it sets a transaction timeout for any transaction started by a subsequent call to begin on this instance
            5. Boolean isAlive() —> check if transaction is still alive
            6. Void registerSynchronization(Synchronisation s) registers a user synchronisation callback for this transaction
            7. Boolean wasCommited() checks if the transaction is committed successfully
            8. Boolean wasRolledBack() checks if the transaction is rollback successfully
14. HQL
    1. Instead of table name, we use classname in HQL
    2. It is database independent query language
    3. Advantages
        1. Database independent
        2. Supports polymorphic queries
        3. Easy to lear
    4. Query Interface
        1. It is object oriented representation of hibernate query
        2. Can be obtained by. Calling createQuery() method session interface
        3. Commonly used methods are
            1. Int executeUpdate() —> used to execute the update or delete query
            2. List list() returns the result of the relation as a list
            3. Query setFirstResult(int rowNo) —> specifies the row number from where record will be retrieved 
            4. Query setMaxResult(int rowNo) —> specifies the no. of records to be retrieved from the relation
            5. Query setParameter(int position, Object value)  —> it sets the value to JDBC style query parameter
            6. Query setParameter(String name, Object value) —> it sets the value to a named query parameter
15. HCQL
    1. Hibernate Criteria Query Language
    2. Uses Criteria interface to apply criteria such as greater than X
    3. Advantages
        1. Easy to add criteria
        2. Many criteria can be added on a query
    4. Criteria Interface
        1. The object of criteria  can be created using createCriteria() method of session interface
        2. Criteria add(Criterion c) —> used to add restrictions
        3. Criteria addOrder(Order o) —> specifies ordering
        4. Criteria setFirstResult(int firstResult) —> specifies the first number of record to be retrieved
        5. Criteria setMaxResult(int totalResult) —> specifies the total number of records to be retrieved
        6. List list() —> returns list containing object
        7. Criteria setProjection(Projection projection) specifies projection
    5. Restriction class
        1. Public static SimpleExpression It(String propertyName, Object value) —> sets the less than constraint to given property
        2. Public static SimpleExpression Ie(String propertyName, Object value) —> sets the less than or equal constraint to given property
        3. Public static SimpleExpression gt(String propertyName, Object value) —> sets the greater than constraint to given property
        4. Public static SimpleExpression ge(String propertyName, Object value) —> sets the greater than or equal constraint to given property
        5. Public static SimpleExpression ne(String propertyName, Object value) —> sets the not equal constraint to given property
        6. Public static SimpleExpression eq(String propertyName, Object value) —> sets the equal constraint to given property
        7. Public static Criterion  between(String propertyName, Object low, Object high) —> sets the between constraint to given property
        8. Public static SimpleExpression like(String propertyName, Object value) —> sets the like constraint to given property
    6. Order class
        1. Public static Order asc(String propertyName)) —> applies the ascending order on basics of given property
        2. Public static Order desc(String propertyName)) —> applies the descending order on basics of given property
16. Named Query
    1. It is a way to use any query by some meaningful name. It is like using alias names
    2. Two ways to define named query
        1. Annotation 
        2. Mapping file
    3. By Annotation
        1. @NamedQueries is used to define multiple named queries
        2. @NamedQuery is used to define single named query
        3. Session.getNamedQuery(“name”)
17. Caching 
        1. Improves performance of application by pooling objects in cache
        2. The are of two types
            1. First level cache
            2. Second level cache
        3. First level cache
            1. Session objects holds the first level cache data
            2. It is enabled by default
            3. Not available for entire application as application has many sessions
        4. Second level cache
            1. SessionFactory object holds the second level cache data
            2. The data is available for entire application
            3. We need to enable it explicitly
            4. Vendors
                1. EH (Easy hibernate) cache
                2. Swarn cache
                3. OS cache
                4. JBoss cache
            5. Four ways to use second level cache
                1. Read-only —> caching will work only for read operation
                2. Construct-read-write —> caching will work for read and write but one at a time
                3. Read-write —> caching will work for read and write, can be used simultaneously
                4. Transactional —> caching will work for transaction (Only for JBoss)
18. Hibernate LifeCycle
    1. The persistent context sits between client code and data store
    2. It is a staging area where persistent data is converted to entities, ready ti be read and altered by client code
    3. The persistence context is an implementation of unit of work pattern. It keeps track of all loaded data, tracks changes of that data and its responsible to eventually synchronise any changes back to the database at the end of business transaction
    4. JPA entityManager and Hibernate’s session are an implementation of the persistence context concept
    5. Managed entity
        1. It is a representation of database table row
        2. This is managed by the currently running session and every change made on it will be tracked and propagated to database automatically
        3. On call to transaction commit() or flush(), the session will find any dirty entities from its tracking list and synchronise the state to the database
    6. Contains following states
        1. Transient
        2. Persistent
        3. Detached
    7. Transient state
        1. It is initial state of an object
        2. Once we create an instance of a POJO class, the object enters transient state
        3. Here object is not associated with any session, so transient state is not related to database
        4. Modification in data doesn’t affect any changes in database
        5. Transient objects only exits in heap memory. They are independent of hibernate
        6. It is simply an entity object that has no representation in the persistent store and is not managed by any session
        7. 
    8. Persistent state
        1. As soon as object is associated with a session it enters persistent state
        2. When we save or persist object
        3. Each object represent a row in database table
        4. If we make changes it will be reflected in database
        5. Methods
            1. Session.save(E)
            2. Session.persist(E)
            3. Session.update(E)
            4. Session.saveOrUpdate(E)
            5. Session.lock(E)
            6. Session.merge(E)
        6. Detached state
            1. Once we either close the session or clear cache, the object enters detached state
            2. Object is no more associated with session, modification in data won’t affect database
            3. The detached object still has a representation in database
            4. If we want to persist the changes made to a detached object, it is required to reattach the application to a valid hibernate session
            5. To associate detached object to a new hibernate session
                1. Load()
                2. merge()
                3. refresh()
                4. update()
                5. save()
            6. To detach an object use
                1. Session.close()
                2. Session.clear()
                3. Session.detach(E)
                4. Session.evict(E)
        7. If you set Id of a transient object which is equal to id of detached/persistent object and call session.update(object), session will consider it to be detached entity and work same as how detach entity works
        8. Session doesn’t distinguish where a re-attached entity originated from
        9. Deleted entity
            1. An entity is deleted(removed) state if session.delete(entity) has been called.
            2. The session marks the entity for deletion
            3. The DELETE command itself might be issued at the end of the unit of work
19. Core interfaces of hibernate
    1. Configuration
    2. SessionFactory
    3. Session
    4. Query
    5. Criteria
    6. Transaction
20. Advantages of ORM over JDBC
    1. Application development is fast
    2. Management of transaction
    3. Generates key automatically
    4. Details of SQL queries are hidden
21. To create SQL query
    1. Session.createSQLQuery
22. To create HQL query
    1. session.createQuery
23. Persistent classes
    1. Classes whose objects are stored in database tables
24. SessionFactory is thread safe
25. Session isn not thread safe
26. Save vs Persist
    1. Save —> returns identifier (Serialisable) of the instance
    2. Persist —> Returns nothing
27. Get vs load
    1. Get 
        1. Returns null if object is not found
        2. Always hit the database
        3. Returns real object not a proxy
        4. Should be used if you are not sure about existence of instance
    2. Load
        1. Throws ObjectNotFoundException if object is not found
        2. Doesn’t hit the database
        3. Proxy object
        4. Should be used if you are sure that instance exists
28. Update vs merge
    1. Update 
        1. To edit something
        2. Should be used if session doesn’t contain an already persistent state with the same id.
        3. Means an update should be used inside session only. 
        4. After closing session it will throw error
    2. Merge
        1. To combine something
        2. Should be used if you don’t know the state of the session, 
        3. Means you want to make modification at anytime
29. Automatic dirty checking
    1. This feature calls update statement automatically on the objects that are modified in the transaction
30. Collection mapping can only be performed with One-To-Many and Many-To-Many
31. Flush vs commit
    1. Session flush is the process of synchronising the underlying persistent state held in memory 
    2. Flushing the session simply gets the data in the session synchronised with the database
    3. If a persistent object in the session has value change, it becomes dirty, and session flush will update the database in the running transaction but it. May not commit those changes
32. JPA entity life cycle events
    1. Before persist is called for a new entity - @PrePersist
    2. After persist is called for a new entity - @PostPersist
    3. Before an entity is removed - @PreRemove
    4. After an entity has been deleted - @PostRemove
    5. Before the update operation - @PreUpdate
    6. After an entity is updated - @PostUpdate
    7. After an entity has been loaded - @PostLoad
33. Approach to lifecycle event annotations
    1. Annotating methods in the entity
    2. Creating an entityListener with annotated callback methods
    3. We can use both at the same time
    4. Callback methods are required to have a void return type
    5. If we’re using @GeneratedValue to automatically generate our primary keys, we can expect that key to be available in the @PostPersist method
    6. @PreUpdate is only called if the data is actually changed - that. Is there’s an actual SQL update statement to run
    7. The @PostUpdate callback its called regardless of whether anything actually changed
    8. If any of our callbacks for persisting or removing an entity throw an exception, the transaction will be rolled back
34. JPA @Basic
    1. A basic type maps directly to a column in the database
    2. The @Basic annotation on a field or a property signifies that its a basic type and Hibernate should use the standard mapping for its persistence
    3. It’s an optional annotation
    4. When we don’t specify the @Basic annotation for a basic type attribute, it is implicitly assumed, and the default values of this annotation apply
    5. @Basic annotation has two attributes
        1. Optional
            1. The optional attribute is a boolean parameter that defines whether the marked field or property allows null
            2. It defaults to true
        2. Fetch
            1. Accepts a member of the enumeration Fetch which specifies whether the marked field or property should be lazily loaded or eagerly fetched 
35. JPA @Basic vs @Column
    1. Attributes of the @Basic annotation are applied to JPA entities whereas the attributes of the @COlumn are applied to the database columns
    2. @Basic annotations optional attribute  defines whether the entity field can be null or not; on the other hand @Column annotation’s nullable attribute specifies whether the corresponding database column can be null
    3. We can use @Basic to indicate that a field should be lazily loaded
    4. The @Column annotation allows us to specify the name of the mapped database column 
36. @Size , @Length @Column(length=value)
    1. @Size
        1. @Size is a bean validation annotation
        2. @Size makes the bean independent of JPA and its vendors such as hibernate, As a result this is more portable than @Lenght
    2. @Length
        1. It is hibernate-specific version of @Size
    3. @Column(length=value)
        1. Used to indicate specific characteristics of physical database column.
        2. It doesn’t provide validations
        3. We can use @Column together with @Size to specify database column properly and also have validation
37. JPA @Embedded and @Embeddable
    1. If we have attributes in our class which can be abstracted out to a septette class but we don’t want to create a separate table for those details we can use 
    2. @Embeddable
        1. JPA provides the @Embeddable annotation to declare that a class will be embedded by other entities
    3. @Embedded
        1. The JPA @Embedded is used to embed a type into another entity
    4. Now there can be an instance that the new embedded class doesn’t have same attribute name to solve this we have attributes override
    5. We can use @AttributeOverrides and @AttribuuteOverride to override the column properties of our embedded types
38. Hibernate @NotNull vs @Column(nullable=false)
    1. Both are used to prevent null data
    2. The @NotNull annotation is defined in the bean validation specification. This means it is not limited only to entities
    3. The hibernate doesn’t trigger the SQL insert statement of data is invalid because the pre-persist entity lifecycle event triggered the bean validation just before send the query to database
    4. Out of the box hibernate translates the bean validation annotations applied to the entities into the DDL schema metadata
    5. If we don’t want hibernate to automatically create schema with validations we need to set hibernate.validator.apply_to_ddl property to false
    6. @Column(nullable=false) is defined as part of JPA specification. It will also create the schema with validations as it use hibernate
    7. Hibernate is able to perform the validation of the entity against the possible null values even if the corresponding field is annotated only with @Column(nullable=false)
    8. We should prefer @NotNull over @Column(nullable=false)



1. Association
    1. Association is relation between two separate classes through their objects
    2. One to one
    3. One to many
    4. Many to one
    5. Many to many
    6. Composition and aggregation are two forms of association
2. Aggregation
    1. It is weak association
    2. It represents Has-A relationship
    3. It is unidirectional association
    4. In aggregation both the entires can survive individually 
    5. Code reuse is best achieved by aggregation
3. Composition
    1. It is strong association
    2. Composition is a restricted form of aggregation in which two entities are highly dependent on each other
    3. It represent part-of relationship
    4. Both entities depend on each other
    5. Composed object cannot exists without the other entity

