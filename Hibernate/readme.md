#Hibernate

1. Hibernate framework
    1. It is an open source, light weight, ORM tool
    2. Hibernate implements the JPA specifications for data persistence
2. ORM Tool
    1. ORM simplifies the data creation, manipulation and access
    2. It maps objects to data stored in database
    3. Internally uses JDBC api to interact. With database
3. JPA
    1. It is a java specification that provides certain functionality and standard to ORM tools
4. Advantages
    1. Open source and light weight
    2. Fast performance
        1. Uses cache internally.
        2. There are two types of cache
            1. First level cache
            2. Second level cache (optional)
    3. Database independent query
        1. HQL (Hibernate query language) is the object oriented version of SQL. 
        2. It generates database independent queries
        3. If database changes, the queries won’t have to be written again
    4. Automatic table creation
    5. Simplifies complex joins
    6. Provides query statistics and database status
5. Hibernate Architecture
    1. There are 4 layers
        1. Java application layer
        2. Hibernate framework layer
        3. Backend api layer
        4. Database layer
6. Elements of Hibernate
    1. SessionFactory
        1. It is a factory of session and client of connectionProvider
        2. It holds second level cache of data
        3. Used to get session object
    2. Session
        1. Provides an interface between the application and data stored in database
        2. It is a short lived object and wraps the JDBC connection
        3. It is factory of transaction, query and criteria
        4. It holds first level of cache
    3. Transaction
        1. The transaction object specifies the atomic unit of work
        2. It is optional
    4. ConnectionProvider
        1. It is a factory of JDBC connection.
        2. It abstracts the application from drivermanager or datasource
        3. It is optional
    5. Transaction factory
        1. It is factory of transaction
7. Steps 
    1. Create the persistent class
        1. A no-arg constructor
            1. So that hibernate can create the instance of persistent class by newInstance() method
        2. Provide an identifier property
            1. The attribute behaves like primary key in database
        3. Declare getter and setter methods
        4. Prefer non-final class
            1. Hibernate uses the concept of proxies, that depends on the persistent class
    2. Create mapping file for persistent class
        1. If you have created persistent class using annotations, no need to create xml for below steps
        2. Hibernate-mapping
            1. It is the root element in mapping file
        3. Class
            1. It is the sub element of hibernate-mapping element, specifies persistent class
        4. Id
            1. it is sub element of class element, It specifies primary key attribute in the class
        5. Generator
            1. It is sub element of id
            2. Used to generate primary key
        6. Property
            1. It is sub element of class that specifies the property name of persistent class
    3. Create configuration file
        1. Contains information about the database and mapping file
    4. Create the class that retrieves or stores the object
    5. Run the application
8. Generator classes in hibernate
    1. Assigned
        1. It is default strategy
    2. Increment
        1. It generates the unique id only if no other process is inserting data into this table
        2. It generates short, int or long type identifier
    3. Sequence
        1. It uses the sequence of the database, if no sequence is defined it creates a sequence automatically
    4. Hilo
        1. It uses high and low algorithm to generate the id of type short, int and long
    5. Native
        1. It uses identity, sequence or hilo depending on database vendor
    6. Identity
        1. It is responsibility of database to generate unique identifier
    7. Seqhilo
        1. It uses high and low algorithm on the specified sequence name
        2. Returned id is of type short, int to long
    8. UUID
        1. It uses 128 bit UUID algorithm to generate the id
        2. The returned id is of type String, and unique within the network
    9. GUID
        1. It uses GUID generated by database of type string
    10. SELECT
        1. It uses primary key returned by database trigger
    11. Sequence-identity
        1. It is supported in oracle 10g drivers only
9. SQL dialects in hibernate
    1. The dialect specifies the type of database used in hibernate so that hibernate generate appropriate type of SQL statements
10. Inheritance mapping
    1. There are there strategies
        1. Table per hierarchy
            1. Single table is required to map the whole hierarchy
            2. An extra column (known as discriminator column) is added to identify the class
            3. Nullable values are stored in the table
        2. Table per concrete class
            1. Tables are created per class
            2. Duplicate column is added in subclass table
            3. Union-subclass subelement of class, specifies the subclass. 
            4. @inheritence(strategy=Inheritencetype.TABLE_PER_CLASS) specifies that we are using table per concrete class strategy
            5. @AttributeOverrides defines the parent class attributes will be override in this class
        3. Table per subclass
            1. Tables are created per class but related by foreign key
            2. There are no duplicate column
            3. Joined-subclass element of class issued to map the child class with parent using primary & foreign key relation
            4. @Inheritence(strategy=InheritenceType.JOINED)
            5. @PrimaryKeyJoinColumn in subclass
11. Collection mapping
    1. Supported types are
        1. Set
        2. List
        3. SortedSet
        4. Map
        5. SortedMap
        6. Collection
    2. Collection elements can be categorised in two forms
        1. Indexed - Map, List
        2. Non-indexed - Set, bag
12. Relation mapping
    1. One to many
        1. @OneToMany , @JoinColumn, @OrderColumn in parent class
    2. Many to Many
        1. @ManyToMany(targetEntity= Target.class, cascade= CascadeType.ALL)), @JoinTable(name =“intermediate table name”, joinColumns = {@JoinColumn(name=“parent_fk”)}, inverseJoinColumns = {@JoinColumn(name=“taget_fk”)}
    3. One to One
        1. @OneToOne(targetEntity=Target.class, cascade=CascadeType.ALL) in parent
        2. @OneToOne(targetEntity=Parent.class, cascade=CascadeType.ALL) in target
    4. Many to One
        1. @ManyToOne(cascade=CascadeType.ALL) in parent
13. Transaction Management
    1. A transaction represents unit of work
    2. It can be described by ACID property (Atomicity, Consistency, Isolation, Durability)
    3. A transaction is associated with a session and instantiated by calling session.beginTransaction()
        1. Methods are
            1. Void begin() —> starts a new transaction
            2. Void commit() —> ends the unit of work unless we are in FlushMode.NEVER
            3. Void rollback() —> forces this transaction to rollback
            4. Void setTimout(int seconds) —> it sets a transaction timeout for any transaction started by a subsequent call to begin on this instance
            5. Boolean isAlive() —> check if transaction is still alive
            6. Void registerSynchronization(Synchronisation s) registers a user synchronisation callback for this transaction
            7. Boolean wasCommited() checks if the transaction is committed successfully
            8. Boolean wasRolledBack() checks if the transaction is rollback successfully
14. HQL
    1. Instead of table name, we use classname in HQL
    2. It is database independent query language
    3. Advantages
        1. Database independent
        2. Supports polymorphic queries
        3. Easy to lear
    4. Query Interface
        1. It is object oriented representation of hibernate query
        2. Can be obtained by. Calling createQuery() method session interface
        3. Commonly used methods are
            1. Int executeUpdate() —> used to execute the update or delete query
            2. List list() returns the result of the relation as a list
            3. Query setFirstResult(int rowNo) —> specifies the row number from where record will be retrieved 
            4. Query setMaxResult(int rowNo) —> specifies the no. of records to be retrieved from the relation
            5. Query setParameter(int position, Object value)  —> it sets the value to JDBC style query parameter
            6. Query setParameter(String name, Object value) —> it sets the value to a named query parameter
15. HCQL
    1. Hibernate Criteria Query Language
    2. Uses Criteria interface to apply criteria such as greater than X
    3. Advantages
        1. Easy to add criteria
        2. Many criteria can be added on a query
    4. Criteria Interface
        1. The object of criteria  can be created using createCriteria() method of session interface
        2. Criteria add(Criterion c) —> used to add restrictions
        3. Criteria addOrder(Order o) —> specifies ordering
        4. Criteria setFirstResult(int firstResult) —> specifies the first number of record to be retrieved
        5. Criteria setMaxResult(int totalResult) —> specifies the total number of records to be retrieved
        6. List list() —> returns list containing object
        7. Criteria setProjection(Projection projection) specifies projection
    5. Restriction class
        1. Public static SimpleExpression It(String propertyName, Object value) —> sets the less than constraint to given property
        2. Public static SimpleExpression Ie(String propertyName, Object value) —> sets the less than or equal constraint to given property
        3. Public static SimpleExpression gt(String propertyName, Object value) —> sets the greater than constraint to given property
        4. Public static SimpleExpression ge(String propertyName, Object value) —> sets the greater than or equal constraint to given property
        5. Public static SimpleExpression ne(String propertyName, Object value) —> sets the not equal constraint to given property
        6. Public static SimpleExpression eq(String propertyName, Object value) —> sets the equal constraint to given property
        7. Public static Criterion  between(String propertyName, Object low, Object high) —> sets the between constraint to given property
        8. Public static SimpleExpression like(String propertyName, Object value) —> sets the like constraint to given property
    6. Order class
        1. Public static Order asc(String propertyName)) —> applies the ascending order on basics of given property
        2. Public static Order desc(String propertyName)) —> applies the descending order on basics of given property
16. Named Query
    1. It is a way to use any query by some meaningful name. It is like using alias names
    2. Two ways to define named query
        1. Annotation 
        2. Mapping file
    3. By Annotation
        1. @NamedQueries is used to define multiple named queries
        2. @NamedQuery is used to define single named query
        3. Session.getNamedQuery(“name”)
17. Caching 
        1. Improves performance of application by pooling objects in cache
        2. The are of two types
            1. First level cache
            2. Second level cache
        3. First level cache
            1. Session objects holds the first level cache data
            2. It is enabled by default
            3. Not available for entire application as application has many sessions
        4. Second level cache
            1. SessionFactory object holds the second level cache data
            2. The data is available for entire application
            3. We need to enable it explicitly
            4. Vendors
                1. EH (Easy hibernate) cache
                2. Swarn cache
                3. OS cache
                4. JBoss cache
            5. Four ways to use second level cache
                1. Read-only —> caching will work only for read operation
                2. Construct-read-write —> caching will work for read and write but one at a time
                3. Read-write —> caching will work for read and write, can be used simultaneously
                4. Transactional —> caching will work for transaction (Only for JBoss)
18. Hibernate LifeCycle
    1. Contains following states
        1. Transient
        2. Persistent
        3. Detached
    2. Transient state
        1. It is initial state of an object
        2. Once we create an instance of a POJO class, the object enters transient state
        3. Here object is not associated with any session, so transient state is not related to database
        4. Modification in data doesn’t affect any changes in database
        5. Transient objects only exits in heap memory. They are independent of hibernate
    3. Persistent state
        1. As soon as object is associated with a session it enters persistent state
        2. When we save or persist object
        3. Each object represent a row in database table
        4. If we make changes it will be reflected in database
        5. Methods
            1. Session.save(E)
            2. Session.persist(E)
            3. Session.update(E)
            4. Session.saveOrUpdate(E)
            5. Session.lock(E)
            6. Session.merge(E)
        6. Detached state
            1. Once we either close the session or clear cache, the object enters detached state
            2. Object is no more associated with session, modification in data won’t affect database
            3. The detached object still has a representation in database
            4. If we want to persist the changes made to a detached object, it is required to reattach the application to a valid hibernate session
            5. To associate detached object to a new hibernate session
                1. Load()
                2. merge()
                3. refresh()
                4. update()
                5. save()
            6. To detach an object use
                1. Session.close()
                2. Session.clear()
                3. Session.detach(E)
                4. Session.evict(E)
19. Core interfaces of hibernate
    1. Configuration
    2. SessionFactory
    3. Session
    4. Query
    5. Criteria
    6. Transaction
20. Advantages of ORM over JDBC
    1. Application development is fast
    2. Management of transaction
    3. Generates key automatically
    4. Details of SQL queries are hidden
21. To create SQL query
    1. Session.createSQLQuery
22. To create HQL query
    1. session.createQuery
23. Persistent classes
    1. Classes whose objects are stored in database tables
24. SessionFactory is thread safe
25. Session isn not thread safe
26. Save vs Persist
    1. Save —> returns identifier (Serialisable) of the instance
    2. Persist —> Returns nothing
27. Get vs load
    1. Get 
        1. Returns null if object is not found
        2. Always hit the database
        3. Returns real object not a proxy
        4. Should be used if you are not sure about existence of instance
    2. Load
        1. Throws ObjectNotFoundException if object is not found
        2. Doesn’t hit the database
        3. Proxy object
        4. Should be used if you are sure that instance exists
28. Update vs merge
    1. Update 
        1. To edit something
        2. Should be used if session doesn’t contain an already persistent state with the same id.
        3. Means an update should be used inside session only. 
        4. After closing session it will throw error
    2. Merge
        1. To combine something
        2. Should be used if you don’t know the state of the session, 
        3. Means you want to make modification at anytime
29. Automatic dirty checking
    1. This feature calls update statement automatically on the objects that are modified in the transaction
30. Collection mapping can only be performed with One-To-Many and Many-To-Many
31. Flush vs commit
    1. Session flush is the process of synchronising the underlying persistent state held in memory 
    2. Flushing the session simply gets the data in the session synchronised with the database
    3. If a persistent object in the session has value change, it becomes dirty, and session flush will update the database in the running transaction but it. May not commit those changes